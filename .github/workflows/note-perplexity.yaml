name: Note Workflow (Gemini Ver.)

on:
  workflow_dispatch:
    inputs:
      theme:
        description: '記事テーマ'
        required: true
        type: string
      target:
        description: '想定読者（ペルソナ）'
        required: true
        type: string
      message:
        description: '読者に伝えたい核メッセージ'
        required: true
        type: string
      cta:
        description: '読後のアクション（CTA）'
        required: true
        type: string
      tags:
        description: 'カンマ区切りタグ（任意）'
        required: false
        default: ''
        type: string
      is_public:
        description: '公開(true)/下書き(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: '投稿をスキップ（生成のみ）'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  research:
    name: Research (Gemini + Tavily)
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/google # ★★★ここを @ai-sdk/google に修正！★★★
      - name: Research with Gemini + Tavily
        run: |
          cat > research.mjs <<'EOF'
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google'; // ★★★ここを @ai-sdk/google に修正！★★★
          import fs from 'fs';
          const theme = process.env.THEME || '';
          const target = process.env.TARGET || '';
          const today = new Date().toISOString().slice(0,10);
          const artifactsDir = '.note-artifacts';
          fs.mkdirSync(artifactsDir, { recursive: true });
          const TAVILY_API_KEY = process.env.TAVILY_API_KEY || '';
          const modelName = 'gemini-2.0-flash-lite';
          
          if (!TAVILY_API_KEY) { console.error('TAVILY_API_KEY is not set'); process.exit(1); }
          async function tavilySearch(q) {
            const res = await fetch('https://api.tavily.com/search', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ api_key: TAVILY_API_KEY, query: q, search_depth: 'advanced', max_results: 7, include_answer: true })
            });
            if (!res.ok) { return { query: q, results: [], answer: null }; }
            const json = await res.json().catch(() => ({}));
            return { query: q, results: Array.isArray(json.results) ? json.results : [], answer: json.answer || null };
          }
          
          function formatEvidence(items) {
            const lines = [];
            for (const it of items) {
              lines.push(`### 検索クエリ: ${it.query}`);
              if (it.answer) { lines.push(`Tavilyの回答: ${it.answer}`); }
              for (const r of it.results || []) {
                const t = (r.title || '').toString();
                const u = (r.url || '').toString();
                const c = (r.content || '').toString().slice(0, 500);
                lines.push(`- [${t}](${u})\n  ${c}`);
              }
              lines.push('');
            }
            return lines.join('\n');
          }
          async function main() {
            const searchQuery = `「${theme}」について、ターゲット「${target}」向けの最新情報。一次情報（公的機関・規格・論文・公式）を優先して検索。`;
            const searchResult = await tavilySearch(searchQuery);
            const evidence = formatEvidence([searchResult]);
            
            const sys = [
              'あなたは最新情報の収集と要約に特化した超一流のリサーチャーです。',
              '提供された検索結果（エビデンス）に基づき、事実ベースでレポートを作成してください。',
              '本文内にMarkdownリンクで出典を必ず埋め込むこと。',
              '十分な分量（目安: 2,000語以上）で、章立てして詳細に記述してください。',
            ].join('\n');
            const userPrompt = `以下のテーマ、ターゲット、エビデンスに基づき、最終版のリサーチレポートを作成してください。\n【重要】途中経過や確認質問は一切せず、最終レポートのみを返してください。\n---\nテーマ: ${theme}\nターゲット: ${target}\n現在日付: ${today}\n\n## エビデンス（Tavily検索結果）\n${evidence}`;
            
            const { text } = await generateText({
              model: google(modelName), // ★★★ここを google() に修正！★★★
              system: sys,
              prompt: userPrompt,
              temperature: 0.5,
              maxTokens: 8000,
            });
            
            const assistantTexts = text || '';
            fs.writeFileSync(`${artifactsDir}/research.md`, assistantTexts);
            try { fs.writeFileSync(`${artifactsDir}/research_trace.json`, JSON.stringify({ searchResult, report: assistantTexts }, null, 2)); } catch {}
          }
          
          await main();
          EOF
          node research.mjs
      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: |
            .note-artifacts/research.md
            .note-artifacts/research_trace.json
  write:
    name: Write (Gemini)
    needs: research
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/google # ★★★ここを @ai-sdk/google に修正！★★★
      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md
      - name: Generate draft (title/body/tags)
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google'; // ★★★ここを @ai-sdk/google に修正！★★★
          import fs from 'fs';
          const theme=process.env.THEME||''; const target=process.env.TARGET||''; const message=process.env.MESSAGE||''; const cta=process.env.CTA||'';
          const inputTags=(process.env.INPUT_TAGS||'').split(',').map(s=>s.trim()).filter(Boolean);
          const researchReport=fs.readFileSync('.note-artifacts/research.md','utf8');
          const modelName = 'gemini-2.0-flash-lite';
          function extractJsonFlexible(raw){const t=(raw||'').trim().replace(/\u200B/g,'');try{return JSON.parse(t);}catch{}const m=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/);if(m&&m[1]){try{return JSON.parse(m[1].trim());}catch{}}const f=t.indexOf('{'),l=t.lastIndexOf('}');if(f!==-1&&l!==-1&&l>f){const c=t.slice(f,l+1);try{return JSON.parse(c);}catch{}}return null;}
          
          async function repairJson(raw){
            const sys='あなたはJSON整形アシスタントです。入力されたテキストから、{"title":string,"draftBody":string,"tags":string[]} の形式でJSONオブジェクトを抽出または生成し、JSON文字列のみを返してください。JSON以外のテキストは一切含めないでください。';
            const {text}=await generateText({
              model: google(modelName), // ★★★ここを google() に修正！★★★
              system:sys,
              prompt:String(raw),
              temperature:0,
              maxTokens:8000,
              // responseFormat: { type: 'json' }, // ★Gemini ProはJSONモードをサポートしてないことがあるので、いったんコメントアウト
            });
            return extractJsonFlexible(text||'');
          }
          
          function sanitizeTitle(t){
            let s=String(t||'').trim();
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            if(!s) s='タイトル（自動生成）';
            return s;
          }
          function deriveTitleFromText(text){
            const lines=(text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
            const firstReal=lines.find(l=>!/^```/.test(l))||lines[0]||'';
            return sanitizeTitle(firstReal);
          }
          
          const sysWrite='あなたはnote.comに投稿するためのプロのライターです。長文の魅力的な記事を生成してください。\n必ず {"title":"記事タイトル","draftBody":"Markdown形式の記事本文","tags":["タグ1","タグ2"]} という厳密なJSON形式で返答してください。JSON以外のテキストは絶対に含めないでください。\ndraftBodyは6000〜9000文字を目安に十分な分量で、読者を惹きつける導入、具体的な内容（章ごとにH2（##）やH3（###）の小見出しと箇条書きを適切に含めること）、そして読後のアクション（CTA）に繋がる明確な結論を含めてください。';
          const prompt=[
            "以下の要件とリサーチ内容に基づき、note.com用の記事をJSON形式で生成してください。",
            `{テーマ}: ${theme}`,
            `{ペルソナ（読者）}: ${target}`,
            `{リサーチ内容}: ${researchReport}`,
            `{記事で伝えたい核メッセージ}: ${message}`,
            `{読後のアクション(CTA)}: ${cta}`
          ].join('\n');
          
          const {text}=await generateText({
            model: google(modelName), // ★★★ここを google() に修正！★★★
            system:sysWrite,
            prompt,
            temperature:0.7,
            maxTokens:30000,
            // responseFormat: { type: 'json' }, // ★Gemini ProはJSONモードをサポートしてないことがあるので、いったんコメントアウト
          });
          
          let obj=extractJsonFlexible(text||'')||await repairJson(text||'');
          let title, draftBody, tags; if(obj){title=sanitizeTitle(obj.title); draftBody=String(obj.draftBody||'').trim(); tags=Array.isArray(obj.tags)?obj.tags.map(String):[]}
          if(!title||!draftBody){ title=deriveTitleFromText(text||''); const lines=(text||'').split(/\r?\n/); draftBody=lines.slice(1).join('\n').trim()||(text||''); tags=[]}
          if(inputTags.length){tags=Array.from(new Set([...(tags||[]),...inputTags]));}
          fs.writeFileSync('.note-artifacts/draft.json',JSON.stringify({title,draftBody,tags},null,2));
          EOF
          node write.mjs
      - name: Collect draft
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/draft.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Upload draft artifact
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifact
          path: .note-artifacts/draft.json

  factcheck:
    name: Fact-check (Gemini + Tavily)
    needs: write
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
      TITLE: ${{ needs.write.outputs.title }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      final_b64: ${{ steps.collect.outputs.final_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/google # ★★★ここを @ai-sdk/google に修正！★★★
      - name: Restore draft json
        env:
          DRAFT_JSON_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$DRAFT_JSON_B64" | base64 -d > .note-artifacts/draft.json || echo "$DRAFT_JSON_B64" | base64 --decode > .note-artifacts/draft.json
      - name: Fact-check with Tavily
        run: |
          cat > factcheck.mjs <<'EOF'
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google'; // ★★★ここを @ai-sdk/google に修正！★★★
          import fs from 'fs';
          const draft=JSON.parse(fs.readFileSync('.note-artifacts/draft.json','utf8'));
          const modelName = 'gemini-2.0-flash-lite';
          const TAVILY_API_KEY=process.env.TAVILY_API_KEY||'';
          if(!TAVILY_API_KEY){ console.error('TAVILY_API_KEY is not set'); process.exit(1); }
          function extractJsonFlexible(raw){
            const t=(raw||'').trim().replace(/\u200B/g,'');
            try{ const o=JSON.parse(t); return o; }catch{}
            const fence=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/); if(fence&&fence[1]){ try{ return JSON.parse(fence[1].trim()); }catch{} }
            let f=t.indexOf('{'), l=t.lastIndexOf('}'); if(f!==-1&&l!==-1&&l>f){ const cand=t.slice(f,l+1); try{ return JSON.parse(cand); }catch{} }
            f=t.indexOf('['); l=t.lastIndexOf(']'); if(f!==-1&&l!==-1&&l>f){ const cand=t.slice(f,l+1); try{ return JSON.parse(cand); }catch{} }
            return null;
          }
          function stripCodeFence(s){
            const t=String(s||'').trim();
            const m=t.match(/^```[a-zA-Z0-9_-]*\s*([\s\S]*?)\s*```\s*$/); if(m&&m[1]) return m[1].trim();
            return t;
          }
          async function proposeQueries(body){
            const sys='あなたは事実検証の専門家です。入力本文から検証が必要な固有名詞・数値・主張を抽出し、Tavily検索用に日本語の検索クエリを最大10件の配列で返してください。出力は ["クエリ1", "クエリ2"] という厳密なJSON配列のみを返してください。JSON以外のテキストは一切含めないでください。';
            const { text } = await generateText({
              model: google(modelName), // ★★★ここを google() に修正！★★★
              system: sys,
              prompt: String(body),
              temperature: 0,
              maxTokens: 2000,
              // responseFormat: { type: 'json' }, // ★Gemini ProはJSONモードをサポートしてないことがあるので、いったんコメントアウト
            });
            const arr = extractJsonFlexible(text||'');
            return Array.isArray(arr) ? arr.map(String).filter(Boolean).slice(0,10) : [];
          }
          async function tavilySearch(q){
            const res = await fetch('https://api.tavily.com/search', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ api_key: TAVILY_API_KEY, query: q, search_depth: 'advanced', max_results: 5, include_answer: true })
            });
            if(!res.ok){ return { query:q, results:[], answer:null }; }
            const json = await res.json().catch(()=>({}));
            return { query:q, results: Array.isArray(json.results)? json.results: [], answer: json.answer || null };
          }
          function formatEvidence(items){
            const lines = [];
            for(const it of items){
              lines.push(`### 検索: ${it.query}`);
              if(it.answer){ lines.push(`要約: ${it.answer}`); }
              for(const r of it.results||[]){
                const t = (r.title||'').toString();
                const u = (r.url||'').toString();
                const c = (r.content||'').toString().slice(0,500);
                lines.push(`- [${t}](${u})\n  ${c}`);
              }
              lines.push('');
            }
            return lines.join('\n');
          }
          async function main(){
            const queries = await proposeQueries(draft.draftBody||'');
            const results = [];
            for(const q of queries){ results.push(await tavilySearch(q)); }
            const evidence = formatEvidence(results);
            const sys=[
              'あなたは事実検証の専門家です。以下の原稿（note記事の下書き）に対し、提供されたエビデンス（Tavily検索結果）に基づき、',
              '誤情報の修正・低信頼出典の置換・信頼できる一次情報の本文内Markdownリンク埋め込みを行って、修正後の本文のみ返してください。',
              '文体・構成は原稿を尊重し、必要に応じて本文末尾に参考文献セクションを追加してください。',
              '【重要】JSONやコードフェンス（```）は絶対に使わず、Markdownの本文だけを返してください。',
            ].join('\n');
            const prompt = [
              '## 原稿', String(draft.draftBody||''), '', '## エビデンス（Tavily検索結果）', evidence
            ].join('\n\n');
            
            const { text } = await generateText({
              model: google(modelName), // ★★★ここを google() に修正！★★★
              system: sys,
              prompt,
              temperature: 0.3,
              maxTokens: 30000,
            });
            
            let body = stripCodeFence(text||'');
            let title = process.env.TITLE || draft.title || '';
            let tags = Array.isArray(draft.tags)? draft.tags: [];
            const obj = extractJsonFlexible(body);
            if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
              if (obj.title) title = String(obj.title);
              const candidates = [obj.body, obj.draftBody, obj.content, obj.text];
              const chosen = candidates.find(v=>typeof v==='string' && v.trim());
              if (chosen) body = String(chosen);
              if (Array.isArray(obj.tags)) tags = obj.tags.map(String);
            }
            body = stripCodeFence(body);
            const out = { title, body, tags };
            fs.writeFileSync('.note-artifacts/final.json', JSON.stringify(out,null,2));
          }
          await main();
          EOF
          node factcheck.mjs
      - name: Upload fact-check artifact
        uses: actions/upload-artifact@v4
        with:
          name: final-artifact
          path: .note-artifacts/final.json

      - name: Collect final
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/final.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/final.json 2>/dev/null || base64 .note-artifacts/final.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "final_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
  post:
    name: Post to note.com (Playwright)
    needs: factcheck
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: [self-hosted, Windows, X64]
    timeout-minutes: 30
    defaults:
      run:
        shell: powershell -NoProfile -NonInteractive -ExecutionPolicy Bypass -File {0}
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL: https://editor.note.com/new

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright marked
          npx playwright install chromium

      - name: Prepare storageState
        id: state
        run: |
          if (-not $env:STATE_JSON) { Write-Error "NOTE_STORAGE_STATE_JSON secret is not set"; exit 1 }
          $tmp = "$env:RUNNER_TEMP\note-state.json"
          Set-Content -LiteralPath $tmp -Value $env:STATE_JSON -NoNewline -Encoding utf8
          "STATE_PATH=$tmp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      # ★UTF-8で確実に読む（文字化け対策）
      - name: Restore final
        id: draft
        env:
          FINAL_B64: ${{ needs.factcheck.outputs.final_b64 }}
        run: |
          if (-not $env:FINAL_B64) { Write-Error "final_b64 output is empty"; exit 1 }
          $bytes = [Convert]::FromBase64String($env:FINAL_B64)
          [IO.File]::WriteAllBytes("final.json", $bytes)

          $jsonText = Get-Content -LiteralPath "final.json" -Raw -Encoding UTF8
          $obj = $jsonText | ConvertFrom-Json
          "TITLE=$($obj.title)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "TAGS=$([string]::Join(', ', $obj.tags))" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Publish via Playwright (draft or public)
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS:  ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
          START_URL: ${{ env.START_URL }}
          IS_PUBLIC: ${{ env.IS_PUBLIC }}
        run: |
          node post.mjs | Tee-Object -FilePath post.log

      # ★ログからURLとスクショパスを拾って出力（Windows版）
      - name: Parse post outputs
        id: parse
        if: always()
        run: |
          if (Test-Path -LiteralPath "post.log") {
            $txt = Get-Content -LiteralPath "post.log" -Raw -Encoding UTF8
            if ($txt -match "PUBLISHED_URL=(.+)") { "published_url=$($matches[1].Trim())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8 }
            if ($txt -match "DRAFT_URL=(.+)")     { "draft_url=$($matches[1].Trim())"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8 }
            if ($txt -match "SCREENSHOT=(.+)")    { "screenshot=$($matches[1].Trim())"    | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8 }
          }

      # ★Linuxの /tmp をやめて、実際に得たスクショパスを使う
      - name: Upload note screenshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: ${{ steps.parse.outputs.screenshot }}

      - name: Upload post log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: post-log
          path: post.log
