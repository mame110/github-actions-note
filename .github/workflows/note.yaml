name: Note Workflow (Gemini Ver.)

on:
  workflow_dispatch:
    inputs:
      theme:
        description: 'è¨˜äº‹ãƒ†ãƒ¼ãƒ'
        required: true
        type: string
      target:
        description: 'æƒ³å®šèª­è€…ï¼ˆãƒšãƒ«ã‚½ãƒŠï¼‰'
        required: true
        type: string
      message:
        description: 'èª­è€…ã«ä¼ãˆãŸã„æ ¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸'
        required: true
        type: string
      cta:
        description: 'èª­å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆCTAï¼‰'
        required: true
        type: string
      tags:
        description: 'ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã‚¿ã‚°ï¼ˆä»»æ„ï¼‰'
        required: false
        default: ''
        type: string
      is_public:
        description: 'å…¬é–‹(true)/ä¸‹æ›¸ã(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: 'æŠ•ç¨¿ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆç”Ÿæˆã®ã¿ï¼‰'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  research:
    name: Research (Gemini + Tavily)
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/google # â˜…â˜…â˜…ã“ã“ã‚’ @ai-sdk/google ã«ä¿®æ­£ï¼â˜…â˜…â˜…

      - name: Research with Gemini + Tavily
        run: |
          cat > research.mjs <<'EOF'
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google'; // â˜…â˜…â˜…ã“ã“ã‚’ @ai-sdk/google ã«ä¿®æ­£ï¼â˜…â˜…â˜…
          import fs from 'fs';
          const theme = process.env.THEME || '';
          const target = process.env.TARGET || '';
          const today = new Date().toISOString().slice(0,10);
          const artifactsDir = '.note-artifacts';
          fs.mkdirSync(artifactsDir, { recursive: true });
          const TAVILY_API_KEY = process.env.TAVILY_API_KEY || '';
          const modelName = 'gemini-2.0-flash-lite';
          
          if (!TAVILY_API_KEY) { console.error('TAVILY_API_KEY is not set'); process.exit(1); }

          async function tavilySearch(q) {
            const res = await fetch('https://api.tavily.com/search', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ api_key: TAVILY_API_KEY, query: q, search_depth: 'advanced', max_results: 7, include_answer: true })
            });
            if (!res.ok) { return { query: q, results: [], answer: null }; }
            const json = await res.json().catch(() => ({}));
            return { query: q, results: Array.isArray(json.results) ? json.results : [], answer: json.answer || null };
          }
          
          function formatEvidence(items) {
            const lines = [];
            for (const it of items) {
              lines.push(`### æ¤œç´¢ã‚¯ã‚¨ãƒª: ${it.query}`);
              if (it.answer) { lines.push(`Tavilyã®å›ç­”: ${it.answer}`); }
              for (const r of it.results || []) {
                const t = (r.title || '').toString();
                const u = (r.url || '').toString();
                const c = (r.content || '').toString().slice(0, 500);
                lines.push(`- [${t}](${u})\n  ${c}`);
              }
              lines.push('');
            }
            return lines.join('\n');
          }

          async function main() {
            const searchQuery = `ã€Œ${theme}ã€ã«ã¤ã„ã¦ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã€Œ${target}ã€å‘ã‘ã®æœ€æ–°æƒ…å ±ã€‚ä¸€æ¬¡æƒ…å ±ï¼ˆå…¬çš„æ©Ÿé–¢ãƒ»è¦æ ¼ãƒ»è«–æ–‡ãƒ»å…¬å¼ï¼‰ã‚’å„ªå…ˆã—ã¦æ¤œç´¢ã€‚`;
            const searchResult = await tavilySearch(searchQuery);
            const evidence = formatEvidence([searchResult]);
            
            const sys = [
              'ã‚ãªãŸã¯æœ€æ–°æƒ…å ±ã®åé›†ã¨è¦ç´„ã«ç‰¹åŒ–ã—ãŸè¶…ä¸€æµã®ãƒªã‚µãƒ¼ãƒãƒ£ãƒ¼ã§ã™ã€‚',
              'æä¾›ã•ã‚ŒãŸæ¤œç´¢çµæœï¼ˆã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ï¼‰ã«åŸºã¥ãã€äº‹å®Ÿãƒ™ãƒ¼ã‚¹ã§ãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚',
              'æœ¬æ–‡å†…ã«Markdownãƒªãƒ³ã‚¯ã§å‡ºå…¸ã‚’å¿…ãšåŸ‹ã‚è¾¼ã‚€ã“ã¨ã€‚',
              'ååˆ†ãªåˆ†é‡ï¼ˆç›®å®‰: 2,000èªä»¥ä¸Šï¼‰ã§ã€ç« ç«‹ã¦ã—ã¦è©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚',
            ].join('\n');
            const userPrompt = `ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã€ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ã«åŸºã¥ãã€æœ€çµ‚ç‰ˆã®ãƒªã‚µãƒ¼ãƒãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚\nã€é‡è¦ã€‘é€”ä¸­çµŒéã‚„ç¢ºèªè³ªå•ã¯ä¸€åˆ‡ã›ãšã€æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚\n---\nãƒ†ãƒ¼ãƒ: ${theme}\nã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: ${target}\nç¾åœ¨æ—¥ä»˜: ${today}\n\n## ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ï¼ˆTavilyæ¤œç´¢çµæœï¼‰\n${evidence}`;
            
            const { text } = await generateText({
              model: google(modelName), // â˜…â˜…â˜…ã“ã“ã‚’ google() ã«ä¿®æ­£ï¼â˜…â˜…â˜…
              system: sys,
              prompt: userPrompt,
              temperature: 0.5,
              maxTokens: 8000,
            });
            
            const assistantTexts = text || '';
            fs.writeFileSync(`${artifactsDir}/research.md`, assistantTexts);
            try { fs.writeFileSync(`${artifactsDir}/research_trace.json`, JSON.stringify({ searchResult, report: assistantTexts }, null, 2)); } catch {}
          }
          
          await main();
          EOF
          node research.mjs

      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: |
            .note-artifacts/research.md
            .note-artifacts/research_trace.json

  write:
    name: Write (Gemini)
    needs: research
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/google # â˜…â˜…â˜…ã“ã“ã‚’ @ai-sdk/google ã«ä¿®æ­£ï¼â˜…â˜…â˜…

      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md

      - name: Generate draft (title/body/tags)
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google'; // â˜…â˜…â˜…ã“ã“ã‚’ @ai-sdk/google ã«ä¿®æ­£ï¼â˜…â˜…â˜…
          import fs from 'fs';
          const theme=process.env.THEME||''; const target=process.env.TARGET||''; const message=process.env.MESSAGE||''; const cta=process.env.CTA||'';
          const inputTags=(process.env.INPUT_TAGS||'').split(',').map(s=>s.trim()).filter(Boolean);
          const researchReport=fs.readFileSync('.note-artifacts/research.md','utf8');
          const modelName = 'gemini-2.0-flash-lite';
          function extractJsonFlexible(raw){const t=(raw||'').trim().replace(/\u200B/g,'');try{return JSON.parse(t);}catch{}const m=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/);if(m&&m[1]){try{return JSON.parse(m[1].trim());}catch{}}const f=t.indexOf('{'),l=t.lastIndexOf('}');if(f!==-1&&l!==-1&&l>f){const c=t.slice(f,l+1);try{return JSON.parse(c);}catch{}}return null;}
          
          async function repairJson(raw){
            const sys='ã‚ãªãŸã¯JSONæ•´å½¢ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚å…¥åŠ›ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã€{"title":string,"draftBody":string,"tags":string[]} ã®å½¢å¼ã§JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŠ½å‡ºã¾ãŸã¯ç”Ÿæˆã—ã€JSONæ–‡å­—åˆ—ã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚JSONä»¥å¤–ã®ãƒ†ã‚­ã‚¹ãƒˆã¯ä¸€åˆ‡å«ã‚ãªã„ã§ãã ã•ã„ã€‚';
            const {text}=await generateText({
              model: google(modelName), // â˜…â˜…â˜…ã“ã“ã‚’ google() ã«ä¿®æ­£ï¼â˜…â˜…â˜…
              system:sys,
              prompt:String(raw),
              temperature:0,
              maxTokens:8000,
              // responseFormat: { type: 'json' }, // â˜…Gemini Proã¯JSONãƒ¢ãƒ¼ãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãªã„ã“ã¨ãŒã‚ã‚‹ã®ã§ã€ã„ã£ãŸã‚“ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
            });
            return extractJsonFlexible(text||'');
          }
          
          function sanitizeTitle(t){
            let s=String(t||'').trim();
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            if(!s) s='ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰';
            return s;
          }
          function deriveTitleFromText(text){
            const lines=(text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
            const firstReal=lines.find(l=>!/^```/.test(l))||lines[0]||'';
            return sanitizeTitle(firstReal);
          }
          
          const sysWrite='ã‚ãªãŸã¯note.comã«æŠ•ç¨¿ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ã®ãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚é•·æ–‡ã®é­…åŠ›çš„ãªè¨˜äº‹ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚\nå¿…ãš {"title":"è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«","draftBody":"Markdownå½¢å¼ã®è¨˜äº‹æœ¬æ–‡","tags":["ã‚¿ã‚°1","ã‚¿ã‚°2"]} ã¨ã„ã†å³å¯†ãªJSONå½¢å¼ã§è¿”ç­”ã—ã¦ãã ã•ã„ã€‚JSONä»¥å¤–ã®ãƒ†ã‚­ã‚¹ãƒˆã¯çµ¶å¯¾ã«å«ã‚ãªã„ã§ãã ã•ã„ã€‚\ndraftBodyã¯6000ã€œ9000æ–‡å­—ã‚’ç›®å®‰ã«ååˆ†ãªåˆ†é‡ã§ã€èª­è€…ã‚’æƒ¹ãã¤ã‘ã‚‹å°å…¥ã€å…·ä½“çš„ãªå†…å®¹ï¼ˆç« ã”ã¨ã«H2ï¼ˆ##ï¼‰ã‚„H3ï¼ˆ###ï¼‰ã®å°è¦‹å‡ºã—ã¨ç®‡æ¡æ›¸ãã‚’é©åˆ‡ã«å«ã‚ã‚‹ã“ã¨ï¼‰ã€ãã—ã¦èª­å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆCTAï¼‰ã«ç¹‹ãŒã‚‹æ˜ç¢ºãªçµè«–ã‚’å«ã‚ã¦ãã ã•ã„ã€‚';
          const prompt=[
            "ä»¥ä¸‹ã®è¦ä»¶ã¨ãƒªã‚µãƒ¼ãƒå†…å®¹ã«åŸºã¥ãã€note.comç”¨ã®è¨˜äº‹ã‚’JSONå½¢å¼ã§ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚",
            `{ãƒ†ãƒ¼ãƒ}: ${theme}`,
            `{ãƒšãƒ«ã‚½ãƒŠï¼ˆèª­è€…ï¼‰}: ${target}`,
            `{ãƒªã‚µãƒ¼ãƒå†…å®¹}: ${researchReport}`,
            `{è¨˜äº‹ã§ä¼ãˆãŸã„æ ¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸}: ${message}`,
            `{èª­å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³(CTA)}: ${cta}`
          ].join('\n');
          
          const {text}=await generateText({
            model: google(modelName), // â˜…â˜…â˜…ã“ã“ã‚’ google() ã«ä¿®æ­£ï¼â˜…â˜…â˜…
            system:sysWrite,
            prompt,
            temperature:0.7,
            maxTokens:30000,
            // responseFormat: { type: 'json' }, // â˜…Gemini Proã¯JSONãƒ¢ãƒ¼ãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãªã„ã“ã¨ãŒã‚ã‚‹ã®ã§ã€ã„ã£ãŸã‚“ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
          });
          
          let obj=extractJsonFlexible(text||'')||await repairJson(text||'');
          let title, draftBody, tags; if(obj){title=sanitizeTitle(obj.title); draftBody=String(obj.draftBody||'').trim(); tags=Array.isArray(obj.tags)?obj.tags.map(String):[]}
          if(!title||!draftBody){ title=deriveTitleFromText(text||''); const lines=(text||'').split(/\r?\n/); draftBody=lines.slice(1).join('\n').trim()||(text||''); tags=[]}
          if(inputTags.length){tags=Array.from(new Set([...(tags||[]),...inputTags]));}
          fs.writeFileSync('.note-artifacts/draft.json',JSON.stringify({title,draftBody,tags},null,2));
          EOF
          node write.mjs

      - name: Collect draft
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/draft.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload draft artifact
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifact
          path: .note-artifacts/draft.json

  factcheck:
    name: Fact-check (Gemini + Tavily)
    needs: write
    runs-on: ubuntu-latest
    env:
      GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GENERATIVE_AI_API_KEY }}
      TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
      TITLE: ${{ needs.write.outputs.title }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      final_b64: ${{ steps.collect.outputs.final_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/google # â˜…â˜…â˜…ã“ã“ã‚’ @ai-sdk/google ã«ä¿®æ­£ï¼â˜…â˜…â˜…

      - name: Restore draft json
        env:
          DRAFT_JSON_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$DRAFT_JSON_B64" | base64 -d > .note-artifacts/draft.json || echo "$DRAFT_JSON_B64" | base64 --decode > .note-artifacts/draft.json

      - name: Fact-check with Tavily
        run: |
          cat > factcheck.mjs <<'EOF'
          import { generateText } from 'ai';
          import { google } from '@ai-sdk/google'; // â˜…â˜…â˜…ã“ã“ã‚’ @ai-sdk/google ã«ä¿®æ­£ï¼â˜…â˜…â˜…
          import fs from 'fs';
          const draft=JSON.parse(fs.readFileSync('.note-artifacts/draft.json','utf8'));
          const modelName = 'gemini-2.0-flash-lite';
          const TAVILY_API_KEY=process.env.TAVILY_API_KEY||'';
          if(!TAVILY_API_KEY){ console.error('TAVILY_API_KEY is not set'); process.exit(1); }

          function extractJsonFlexible(raw){
            const t=(raw||'').trim().replace(/\u200B/g,'');
            try{ const o=JSON.parse(t); return o; }catch{}
            const fence=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/); if(fence&&fence[1]){ try{ return JSON.parse(fence[1].trim()); }catch{} }
            let f=t.indexOf('{'), l=t.lastIndexOf('}'); if(f!==-1&&l!==-1&&l>f){ const cand=t.slice(f,l+1); try{ return JSON.parse(cand); }catch{} }
            f=t.indexOf('['); l=t.lastIndexOf(']'); if(f!==-1&&l!==-1&&l>f){ const cand=t.slice(f,l+1); try{ return JSON.parse(cand); }catch{} }
            return null;
          }
          function stripCodeFence(s){
            const t=String(s||'').trim();
            const m=t.match(/^```[a-zA-Z0-9_-]*\s*([\s\S]*?)\s*```\s*$/); if(m&&m[1]) return m[1].trim();
            return t;
          }

          async function proposeQueries(body){
            const sys='ã‚ãªãŸã¯äº‹å®Ÿæ¤œè¨¼ã®å°‚é–€å®¶ã§ã™ã€‚å…¥åŠ›æœ¬æ–‡ã‹ã‚‰æ¤œè¨¼ãŒå¿…è¦ãªå›ºæœ‰åè©ãƒ»æ•°å€¤ãƒ»ä¸»å¼µã‚’æŠ½å‡ºã—ã€Tavilyæ¤œç´¢ç”¨ã«æ—¥æœ¬èªã®æ¤œç´¢ã‚¯ã‚¨ãƒªã‚’æœ€å¤§10ä»¶ã®é…åˆ—ã§è¿”ã—ã¦ãã ã•ã„ã€‚å‡ºåŠ›ã¯ ["ã‚¯ã‚¨ãƒª1", "ã‚¯ã‚¨ãƒª2"] ã¨ã„ã†å³å¯†ãªJSONé…åˆ—ã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚JSONä»¥å¤–ã®ãƒ†ã‚­ã‚¹ãƒˆã¯ä¸€åˆ‡å«ã‚ãªã„ã§ãã ã•ã„ã€‚';
            const { text } = await generateText({
              model: google(modelName), // â˜…â˜…â˜…ã“ã“ã‚’ google() ã«ä¿®æ­£ï¼â˜…â˜…â˜…
              system: sys,
              prompt: String(body),
              temperature: 0,
              maxTokens: 2000,
              // responseFormat: { type: 'json' }, // â˜…Gemini Proã¯JSONãƒ¢ãƒ¼ãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãªã„ã“ã¨ãŒã‚ã‚‹ã®ã§ã€ã„ã£ãŸã‚“ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
            });
            const arr = extractJsonFlexible(text||'');
            return Array.isArray(arr) ? arr.map(String).filter(Boolean).slice(0,10) : [];
          }

          async function tavilySearch(q){
            const res = await fetch('https://api.tavily.com/search', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ api_key: TAVILY_API_KEY, query: q, search_depth: 'advanced', max_results: 5, include_answer: true })
            });
            if(!res.ok){ return { query:q, results:[], answer:null }; }
            const json = await res.json().catch(()=>({}));
            return { query:q, results: Array.isArray(json.results)? json.results: [], answer: json.answer || null };
          }

          function formatEvidence(items){
            const lines = [];
            for(const it of items){
              lines.push(`### æ¤œç´¢: ${it.query}`);
              if(it.answer){ lines.push(`è¦ç´„: ${it.answer}`); }
              for(const r of it.results||[]){
                const t = (r.title||'').toString();
                const u = (r.url||'').toString();
                const c = (r.content||'').toString().slice(0,500);
                lines.push(`- [${t}](${u})\n  ${c}`);
              }
              lines.push('');
            }
            return lines.join('\n');
          }

          async function main(){
            const queries = await proposeQueries(draft.draftBody||'');
            const results = [];
            for(const q of queries){ results.push(await tavilySearch(q)); }
            const evidence = formatEvidence(results);
            const sys=[
              'ã‚ãªãŸã¯äº‹å®Ÿæ¤œè¨¼ã®å°‚é–€å®¶ã§ã™ã€‚ä»¥ä¸‹ã®åŸç¨¿ï¼ˆnoteè¨˜äº‹ã®ä¸‹æ›¸ãï¼‰ã«å¯¾ã—ã€æä¾›ã•ã‚ŒãŸã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ï¼ˆTavilyæ¤œç´¢çµæœï¼‰ã«åŸºã¥ãã€',
              'èª¤æƒ…å ±ã®ä¿®æ­£ãƒ»ä½ä¿¡é ¼å‡ºå…¸ã®ç½®æ›ãƒ»ä¿¡é ¼ã§ãã‚‹ä¸€æ¬¡æƒ…å ±ã®æœ¬æ–‡å†…Markdownãƒªãƒ³ã‚¯åŸ‹ã‚è¾¼ã¿ã‚’è¡Œã£ã¦ã€ä¿®æ­£å¾Œã®æœ¬æ–‡ã®ã¿è¿”ã—ã¦ãã ã•ã„ã€‚',
              'æ–‡ä½“ãƒ»æ§‹æˆã¯åŸç¨¿ã‚’å°Šé‡ã—ã€å¿…è¦ã«å¿œã˜ã¦æœ¬æ–‡æœ«å°¾ã«å‚è€ƒæ–‡çŒ®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚',
              'ã€é‡è¦ã€‘JSONã‚„ã‚³ãƒ¼ãƒ‰ãƒ•ã‚§ãƒ³ã‚¹ï¼ˆ```ï¼‰ã¯çµ¶å¯¾ã«ä½¿ã‚ãšã€Markdownã®æœ¬æ–‡ã ã‘ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚',
            ].join('\n');
            const prompt = [
              '## åŸç¨¿', String(draft.draftBody||''), '', '## ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ï¼ˆTavilyæ¤œç´¢çµæœï¼‰', evidence
            ].join('\n\n');
            
            const { text } = await generateText({
              model: google(modelName), // â˜…â˜…â˜…ã“ã“ã‚’ google() ã«ä¿®æ­£ï¼â˜…â˜…â˜…
              system: sys,
              prompt,
              temperature: 0.3,
              maxTokens: 30000,
            });
            
            let body = stripCodeFence(text||'');
            let title = process.env.TITLE || draft.title || '';
            let tags = Array.isArray(draft.tags)? draft.tags: [];
            const obj = extractJsonFlexible(body);
            if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
              if (obj.title) title = String(obj.title);
              const candidates = [obj.body, obj.draftBody, obj.content, obj.text];
              const chosen = candidates.find(v=>typeof v==='string' && v.trim());
              if (chosen) body = String(chosen);
              if (Array.isArray(obj.tags)) tags = obj.tags.map(String);
            }
            body = stripCodeFence(body);
            const out = { title, body, tags };
            fs.writeFileSync('.note-artifacts/final.json', JSON.stringify(out,null,2));
          }

          await main();
          EOF
          node factcheck.mjs

      - name: Upload fact-check artifact
        uses: actions/upload-artifact@v4
        with:
          name: final-artifact
          path: .note-artifacts/final.json

      - name: Collect final
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/final.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/final.json 2>/dev/null || base64 .note-artifacts/final.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "final_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  post:
    name: Post to note.com (Playwright)
    needs: factcheck
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright marked
          npx playwright install --with-deps chromium | cat

      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_JSON" || (echo "ERROR: NOTE_STORAGE_STATE_JSON secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_JSON" > "$RUNNER_TEMP/note-state.json"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT

      - name: Ensure jq (post)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Restore final
        id: draft
        env:
          FINAL_B64: ${{ needs.factcheck.outputs.final_b64 }}
        run: |
          test -n "$FINAL_B64" || { echo "final_b64 output is empty"; exit 1; }
          echo "$FINAL_B64" | base64 -d > final.json || echo "$FINAL_B64" | base64 --decode > final.json
          echo "TITLE=$(jq -r .title final.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' final.json)" >> $GITHUB_OUTPUT

      - name: Publish via Playwright (draft or public)
        id: publish
        continue-on-error: true
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
        run: |
          # æœ¬æ–‡ã¯å¾Œç¶šã‚¹ã‚¯ãƒªãƒ—ãƒˆå†…ã§Markdownãƒªãƒ³ã‚¯â†’ç´ URLåŒ–ãªã©ã®å‰å‡¦ç†ã‚’è¡Œã†
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import { marked } from 'marked';
          import fs from 'fs';
          import os from 'os';
          import path from 'path';

          function nowStr(){ const d=new Date(); const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`; }

          const STATE_PATH=process.env.STATE_PATH;
          const START_URL=process.env.START_URL||'https://editor.note.com/new';
          const rawTitle=process.env.TITLE||'';
          const rawFinal=JSON.parse(fs.readFileSync('final.json','utf8'));
          const rawBody=String(rawFinal.body||'');
          const TAGS=process.env.TAGS||'';
          const IS_PUBLIC=String(process.env.IS_PUBLIC||'false')==='true';

          if(!fs.existsSync(STATE_PATH)){ console.error('storageState not found:', STATE_PATH); process.exit(1); }

          const ssDir=path.join(os.tmpdir(),'note-screenshots'); fs.mkdirSync(ssDir,{recursive:true}); const SS_PATH=path.join(ssDir,`note-post-${nowStr()}.png`);

          function sanitizeTitle(t){
            let s=String(t||'').trim();
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            // ã‚¿ã‚¤ãƒˆãƒ«ãŒæ³¢æ‹¬å¼§ã‚„è¨˜å·ã®ã¿ã®æ™‚ã¯ç„¡åŠ¹ã¨ã—ã¦æ‰±ã†
            if (/^[\{\}\[\]\(\)\s]*$/.test(s)) s='';
            if(!s) s='ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰';
            return s;
          }
          function deriveTitleFromMarkdown(md){
            const lines=String(md||'').split(/\r?\n/);
            for (const line of lines){
              const l=line.trim();
              if(!l) continue;
              const m=l.match(/^#{1,3}\s+(.+)/); if(m) return sanitizeTitle(m[1]);
              if(!/^```|^>|^\* |^- |^\d+\. /.test(l)) return sanitizeTitle(l);
            }
            return '';
          }
          function normalizeBullets(md){
            // å…ˆé ­ã®ä¸­é»’ãƒ»ãƒ“ãƒ¥ãƒ¬ãƒƒãƒˆã‚’ç®‡æ¡æ›¸ãã«æ­£è¦åŒ–
            return String(md||'')
              .replace(/^\s*[â€¢ãƒ»]\s?/gm,'- ')
              .replace(/^\s*â—¦\s?/gm,'  - ');
          }
          function unwrapParagraphs(md){
            // æ®µè½ä¸­ã®ä¸å¿…è¦ãªæ”¹è¡Œã‚’ã‚¹ãƒšãƒ¼ã‚¹ã¸ï¼ˆè¦‹å‡ºã—/ãƒªã‚¹ãƒˆ/å¼•ç”¨/ã‚³ãƒ¼ãƒ‰ã¯é™¤å¤–ï¼‰
            const lines=String(md||'').split(/\r?\n/);
            const out=[]; let buf=''; let inFence=false;
            for(const raw of lines){
              const line=raw.replace(/\u200B/g,'');
              if(/^```/.test(line)){ inFence=!inFence; buf+=line+'\n'; continue; }
              if(inFence){ buf+=line+'\n'; continue; }
              if(/^\s*$/.test(line)){ if(buf) out.push(buf.trim()); out.push(''); buf=''; continue; }
              // ç®‡æ¡æ›¸ãã‚„ç•ªå·ä»˜ãã®å­—ä¸‹ã’æ”¹è¡Œã‚’ä¸€è¡Œã«é€£çµ
              if(/^(#{1,6}\s|[-*+]\s|\d+\.\s|>\s)/.test(line)){
                if(buf){ out.push(buf.trim()); buf=''; }
                // æ¬¡ã®æ•°è¡ŒãŒé€£ç¶šã—ã¦å˜èªå˜ä½ã®æ”¹è¡Œã®å ´åˆã¯é€£çµ
                out.push(line.replace(/\s+$/,''));
                continue;
              }
              // è¡Œé ­ãŒ1æ–‡å­—ã‚„æ•°æ–‡å­—ã§æ”¹è¡Œã•ã‚Œã¦ã„ã‚‹ã‚±ãƒ¼ã‚¹ï¼ˆç¸¦ä¼¸ã³ï¼‰ã‚’é€£çµ
              if(buf){ buf += (/[ã€‚.!?)]$/.test(buf) ? '\n' : ' ') + line.trim(); }
              else { buf = line.trim(); }
            }
            if(buf) out.push(buf.trim());
            return out.join('\n');
          }
          function preferBareUrls(md){
            const embedDomains=['openai.com','youtube.com','youtu.be','x.com','twitter.com','speakerdeck.com','slideshare.net','google.com','maps.app.goo.gl','gist.github.com'];
            return String(md||'').replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g,(m,text,url)=>{
              try{
                const u=new URL(url); const host=u.hostname.replace(/^www\./,'');
                const isEmbed = embedDomains.some(d=>host.endsWith(d) || (url.includes('google.com/maps') && d.includes('google.com')));
                return isEmbed ? `${text}\n${url}\n` : `${text} (${url})`;
              }catch{return `${text} ${url}`;}
            });
          }
          function isGarbageLine(line){
            return /^[\s\{\}\[\]\(\)`]+$/.test(line || '');
          }
          function normalizeListItemSoftBreaks(md){
            const lines=String(md||'').split(/\r?\n/);
            const out=[]; let inItem=false;
            const listStartRe=/^(\s*)(?:[-*+]\s|\d+\.\s)/;
            for (let i=0;i<lines.length;i++){
              const line=lines[i];
              if (listStartRe.test(line)){
                inItem=true;
                out.push(line.replace(/\s+$/,''));
                continue;
              }
              if (inItem){
                // ç©ºè¡Œ or æ¬¡ã®ãƒªã‚¹ãƒˆé–‹å§‹ã§ã‚¢ã‚¤ãƒ†ãƒ çµ‚ç«¯
                if (!line.trim()) { out.push(line); inItem=false; continue; }
                if (listStartRe.test(line)) { inItem=false; out.push(line); continue; }
                // ç¶™ç¶šè¡Œã¯1è¡Œã¸é€£çµ
                const last = out.pop() || '';
                out.push(last + ' ' + line.trim());
                continue;
              }
              out.push(line);
            }
            return out.join('\n');
          }
          function splitMarkdownBlocks(md){
            const lines=String(md||'').split(/\r?\n/);
            const blocks=[]; let cur=[]; let inFence=false; let fenceTag='';
            for(const line of lines){
              const m=line.match(/^```(.*)$/);
              if(m){
                if(!inFence){ inFence=true; fenceTag=m[1]||''; cur.push(line); }
                else { inFence=false; fenceTag=''; cur.push(line); blocks.push(cur.join('\n')); cur=[]; continue; }
              } else if(!inFence && line.trim()===''){ if(cur.length){ blocks.push(cur.join('\n')); cur=[]; continue; } }
              else if(!inFence && isGarbageLine(line)) { continue; }
              cur.push(line);
            }
            if(cur.length) blocks.push(cur.join('\n'));
            return blocks.filter(b=>{ const t=b.trim(); return t.length>0 && !isGarbageLine(t); });
          }
          function mdToHtml(block){
            // JSONãŒç´›ã‚Œè¾¼ã‚“ã§ã—ã¾ã£ãŸå ´åˆã¯æœ¬æ–‡å€™è£œã®ã¿æŠ½å‡º
            try{
              const maybe = JSON.parse(block);
              if (maybe && typeof maybe==='object' && !Array.isArray(maybe)){
                const candidates=[maybe.body, maybe.draftBody, maybe.content, maybe.text];
                const chosen=candidates.find(v=>typeof v==='string' && v.trim());
                if (chosen) block = String(chosen);
              }
            }catch{}
            const isList = /^\s*(?:[-*+]\s|\d+\.\s)/.test(block);
            return String(marked.parse(block, { gfm:true, breaks: !isList, mangle:false, headerIds:false }) || '');
          }
          function htmlFromMarkdown(md){
            // å…¨æ–‡ã‚’ä¸€æ‹¬ã§HTMLåŒ–ï¼ˆæ®µè½ãƒ™ãƒ¼ã‚¹ï¼‰ã€‚ãƒªã‚¹ãƒˆä¸­ã®æ„å›³ã—ãªã„ <br> ã‚’é¿ã‘ã‚‹ãŸã‚ breaks=false
            return String(marked.parse(md, { gfm:true, breaks:false, mangle:false, headerIds:false }) || '');
          }
          async function insertHTML(page, locator, html){
            await locator.click();
            await locator.evaluate((el, html) => {
              el.focus();
              const sel = window.getSelection();
              const range = document.createRange();
              range.selectNodeContents(el);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
              document.execCommand('insertHTML', false, html);
            }, html);
          }

          let TITLE=sanitizeTitle(rawTitle);
          let preBody = preferBareUrls(rawBody);
          preBody = normalizeBullets(preBody);
          preBody = normalizeListItemSoftBreaks(preBody);
          preBody = unwrapParagraphs(preBody);
          if(!TITLE || TITLE==='ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰'){
            const d=deriveTitleFromMarkdown(preBody);
            if(d) TITLE=d;
          }
          const blocks = splitMarkdownBlocks(preBody);

          let browser, context, page;
          try{
            browser = await chromium.launch({ headless: true, args: ['--lang=ja-JP'] });
            context = await browser.newContext({ storageState: STATE_PATH, locale: 'ja-JP' });
            page = await context.newPage();
            page.setDefaultTimeout(180000);

            await page.goto(START_URL, { waitUntil: 'domcontentloaded' });
            await page.waitForSelector('textarea[placeholder*="è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«"]');
            await page.fill('textarea[placeholder*="è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«"]', TITLE);

            const bodyBox = page.locator('div[contenteditable="true"][role="textbox"]').first();
            await bodyBox.waitFor({ state: 'visible' });
            const htmlAll = htmlFromMarkdown(preBody);
            let pasted = false;
            try {
              const origin = new URL(START_URL).origin;
              await context.grantPermissions(['clipboard-read','clipboard-write'], { origin });
              await page.evaluate(async (html, plain) => {
                const item = new ClipboardItem({
                  'text/html': new Blob([html], { type: 'text/html' }),
                  'text/plain': new Blob([plain], { type: 'text/plain' }),
                });
                await navigator.clipboard.write([item]);
              }, htmlAll, preBody);
              await bodyBox.click();
              await page.keyboard.press('Control+V');
              await page.waitForTimeout(200);
              pasted = true;
            } catch (e) {
              // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰æ¨©é™ãŒç„¡ã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            }
            if (!pasted) {
              // ä¸€æ‹¬HTMLæŒ¿å…¥ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
              await insertHTML(page, bodyBox, htmlAll);
              await page.waitForTimeout(100);
            }

            if(!IS_PUBLIC){
              const saveBtn = page.locator('button:has-text("ä¸‹æ›¸ãä¿å­˜"), [aria-label*="ä¸‹æ›¸ãä¿å­˜"]').first();
              await saveBtn.waitFor({ state: 'visible' });
              if(await saveBtn.isEnabled()) { await saveBtn.click(); await page.locator('text=ä¿å­˜ã—ã¾ã—ãŸ').waitFor({ timeout: 4000 }).catch(()=>{}); }
              // await page.screenshot({ path: SS_PATH, fullPage: true });
              console.log('DRAFT_URL=' + page.url());
              // console.log('SCREENSHOT=' + SS_PATH);
              return;
            }

            const proceed = page.locator('button:has-text("å…¬é–‹ã«é€²ã‚€")').first();
            await proceed.waitFor({ state: 'visible' });
            for (let i=0;i<20;i++){ if (await proceed.isEnabled()) break; await page.waitForTimeout(100); }
            await proceed.click({ force: true });

            await Promise.race([
              page.waitForURL(/\/publish/i).catch(() => {}),
              page.locator('button:has-text("æŠ•ç¨¿ã™ã‚‹")').first().waitFor({ state: 'visible' }).catch(() => {}),
            ]);

            const tags=(TAGS||'').split(/[\n,]/).map(s=>s.trim()).filter(Boolean);
            if(tags.length){
              let tagInput=page.locator('input[placeholder*="ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°"]');
              if(!(await tagInput.count())) tagInput=page.locator('input[role="combobox"]').first();
              await tagInput.waitFor({ state: 'visible' });
              for(const t of tags){ await tagInput.click(); await tagInput.fill(t); await page.keyboard.press('Enter'); await page.waitForTimeout(120); }
            }

            const publishBtn = page.locator('button:has-text("æŠ•ç¨¿ã™ã‚‹")').first();
            await publishBtn.waitFor({ state: 'visible' });
            for (let i=0;i<20;i++){ if (await publishBtn.isEnabled()) break; await page.waitForTimeout(100); }
            await publishBtn.click({ force: true });

            await Promise.race([
              page.waitForURL(u => !/\/publish/i.test(typeof u === 'string' ? u : u.toString()), { timeout: 20000 }).catch(() => {}),
              page.locator('text=æŠ•ç¨¿ã—ã¾ã—ãŸ').first().waitFor({ timeout: 8000 }).catch(() => {}),
              page.waitForTimeout(5000),
            ]);

            // ... tryãƒ–ãƒ­ãƒƒã‚¯ã®æœ€å¾Œ ...
Â  Â  Â  Â  Â  Â  // await page.screenshot(...);  // ğŸ‘ˆ tryã®ä¸­ã¯æ¶ˆã™ï¼
Â  Â  Â  Â  Â  Â  // console.log('SCREENSHOT=...'); // ğŸ‘ˆ tryã®ä¸­ã¯æ¶ˆã™ï¼
Â  Â  Â  Â  Â  } catch (error) { // ğŸ‘ˆ catch ã‚‚å¿˜ã‚Œãšã«ï¼
Â  Â  Â  Â  Â  Â  console.error('Playwright script failed:', error.message);
Â  Â  Â  Â  Â  Â  throw error;
Â  Â  Â  Â  Â  } finally {
Â  Â  Â  Â  Â  Â  // â¬‡ï¸ ğŸ’–ã“ã“ã«ãŠå¼•ã£è¶Šã—ï¼ğŸ’– â¬‡ï¸
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  if (page) {
Â  Â  Â  Â  Â  Â  Â  Â  console.log(`Taking final screenshot: ${SS_PATH}`);
Â  Â  Â  Â  Â  Â  Â  Â  await page.screenshot({ path: SS_PATH, fullPage: true });
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } catch (ssError) {
Â  Â  Â  Â  Â  Â  Â  console.error('Failed to take screenshot:', ssError.message);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  console.log('SCREENSHOT=' + SS_PATH);
Â  Â  Â  Â  Â  Â  // â¬†ï¸ ğŸ’–ã“ã“ã¾ã§ğŸ’– â¬†ï¸

Â  Â  Â  Â  Â  Â  try{ await page?.close(); }catch{} // ğŸ‘ˆ ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã‚‹ã®ã¯ãã®å¾Œï¼
Â  Â  Â  Â  Â  Â  try{ await context?.close(); }catch{}
Â  Â  Â  Â  Â  Â  try{ await browser?.close(); }catch{}
Â  Â  Â  Â  Â  }
          EOF
Â  Â  Â  Â  Â  node post.mjs | tee post.log
Â  Â  Â  Â  Â  SCRIPT_EXIT_CODE=${PIPESTATUS[0]} # ğŸ‘ˆ ğŸ’– 1. ã“ã®1è¡Œã‚’è¿½åŠ ï¼

Â  Â  Â  Â  Â  url=$(grep '^PUBLISHED_URL=' post.log | tail -n1 | cut -d'=' -f2-)
Â  Â  Â  Â  Â  draft=$(grep '^DRAFT_URL=' post.log | tail -n1 | cut -d'=' -f2-)
Â  Â  Â  Â  Â  shot=$(grep '^SCREENSHOT=' post.log | tail -n1 | cut -d'=' -f2-)
Â  Â  Â  Â  Â  if [ -n "$url" ]; then echo "published_url=$url" >> $GITHUB_OUTPUT; fi
Â  Â  Â  Â  Â  if [ -n "$draft" ]; then echo "draft_url=$draft" >> $GITHUB_OUTPUT; fi
Â  Â  Â  Â  Â  if [ -n "$shot" ]; then echo "screenshot=$shot" >> $GITHUB_OUTPUT; fi

Â  Â  Â  Â  Â  exit $SCRIPT_EXIT_CODE
      - name: Upload screenshot (if any)
        if: always() && steps.publish.outputs.screenshot != ''
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: ${{ steps.publish.outputs.screenshot }}
